{
   "templateGroup": {
      "uuid": "wso2-apim-analytics",
      "name": "WSO2 APIM Analytics",
      "description": "Real Time Analytics of APIM",
      "ruleTemplates": [
         {
            "uuid": "apim_alert_frequent_tier_limit_hitting",
            "name": "APIM Frequent Tier Limit Hitting Alert",
            "description": "Alerts when a user or an application goes beyond the subscribed quota frequently",
            "type": "template",
            "instanceCount": "one",
            "script": "",
            "templates": [
               {
                  "type": "siddhiApp",
                  "content": "@App:name(\"apim_alert_frequent_tier_limit_hitting_0\")\n@App:description(\"Alerts when a user or application goes beyond the subscribed quota frequently\")\n\n@source(type = 'inMemory' , topic = 'ThrottledOutStream')\ndefine stream ThrottledOutStream(\n meta_clientType string,\n username string,\n userTenantDomain string,\n apiName string,\n apiVersion string,\n apiContext string,\n apiCreator string,\n apiCreatorTenantDomain string,\n apiResourceTemplate string,\n apiMethod string,\n applicationId string,\n applicationName string,\n subscriber string,\n throttledOutReason string,\n gatewayType string,\n throttledOutTimestamp long,\n hostname string\n);\n\n@sink(type = 'inMemory', topic = 'TierLimitHittingAlertStream')\ndefine stream TierLimitHittingAlertStream(subscriber string, apiCreator string, apiName string, applicationId string, applicationName string, apiCreatorTenantDomain string, userTenantDomain string, message string, severity int, alertTimestamp long);\n\ndefine stream SuppressedTemporarySubscriberStream(apiCreator string, apiName string, apiVersion string, applicationId string, applicationName string, apiCreatorTenantDomain string, userTenantDomain string, subscriber string, numHits long);\n\ndefine stream SuppressedTemporaryUserStream(username string, apiCreator string, apiName string, apiVersion string, applicationId string, applicationName string, apiCreatorTenantDomain string, userTenantDomain string, subscriber string, numHits long);\n\n--checks whether total throttled out count with the throttled out reson SUBSCRIPTION_LIMIT_EXCEEDED is higer than the specified value\n@info(name = 'TemporarySubscriberStream generating Query: 10 min batch')\nfrom ThrottledOutStream[throttledOutReason == 'SUBSCRIPTION_LIMIT_EXCEEDED']#window.timeBatch(1 min)\nselect apiCreator, apiName, apiVersion, applicationId, applicationName, apiCreatorTenantDomain, userTenantDomain, subscriber, count() as numHits\n \tgroup by apiCreator, apiName, apiVersion, applicationId\ninsert into TemporaryMinWindowSubscriberStream;\n\n@info(name = 'TemporarySubscriberStream generating Query')\nfrom TemporaryMinWindowSubscriberStream#window.time(${countingTime})\nselect apiCreator, apiName, apiVersion, applicationId, applicationName, apiCreatorTenantDomain, userTenantDomain, subscriber, sum(numHits) as numHits\n \tgroup by apiCreator, apiName, apiVersion, applicationId\n \thaving numHits > ${numOfTierCrossing}\ninsert into TemporarySubscriberStream;\n\n--checks whether total throttled out count with the throttled out reson APPLICATION_LIMIT_EXCEEDED is higer than the specified value\n@info(name = 'TemporaryUserStream generating Query: 10 min window')\nfrom ThrottledOutStream[throttledOutReason == 'APPLICATION_LIMIT_EXCEEDED']#window.timeBatch(1 min)\nselect username, apiCreator, apiName, apiVersion, applicationId, applicationName,\napiCreatorTenantDomain, userTenantDomain, subscriber, count() as numHits\n \tgroup by username, apiName, apiVersion, applicationId\ninsert into TemporaryMinwindowUserStream;\n\n--checks whether total throttled out count with the throttled out reson APPLICATION_LIMIT_EXCEEDED is higer than the specified value\n@info(name = 'TemporaryUserStream generating Query')\nfrom TemporaryMinwindowUserStream#window.time(${countingTime})\nselect username, apiCreator, apiName, apiVersion, applicationId, applicationName, apiCreatorTenantDomain, userTenantDomain, subscriber, sum(numHits) as numHits\n \tgroup by username, apiName, apiVersion, applicationId\n \thaving numHits > ${numOfTierCrossing}\ninsert into TemporaryUserStream;\n\n--this query ensures that the same type of alert is not generated for same apiCreator again for a time defined in #window.time(),\n@info(name = 'Query contains Suppression logic')\nfrom TemporarySubscriberStream#window.length(1) as a left outer join SuppressedTemporarySubscriberStream#window.time(${alertSuppressionTime} minutes) as b\n \ton (a.apiCreator == b.apiCreator and a.apiVersion == b.apiVersion and a.applicationId == b.applicationId)\nselect a.apiCreator, a.apiName, a.apiVersion, a.applicationId, a.applicationName, a.apiCreatorTenantDomain, a.userTenantDomain, a.subscriber, a.numHits\n \thaving b.apiCreator is null\ninsert into SuppressedTemporarySubscriberStream ;\n\n--this query ensures that the same type of alert is not generated for same user again for a time defined in #window.time()\n@info(name = 'Alert Suppression')\nfrom TemporaryUserStream#window.length(1) as a left outer join SuppressedTemporaryUserStream#window.time(${alertSuppressionTime} minutes) as b\n \ton (a.username == b.username and a.apiVersion == b.apiVersion and a.applicationId == b.applicationId)\nselect a.username, a.apiCreator, a.apiName, a.apiVersion, a.applicationId, a.applicationName, a.apiCreatorTenantDomain, a.userTenantDomain, a.subscriber, a.numHits\n \thaving b.username is null\ninsert into SuppressedTemporaryUserStream;\n\n@info(name = 'Query generates TierLimitHittingAlertStream')\nfrom SuppressedTemporarySubscriberStream\nselect ifThenElse(userTenantDomain == 'carbon.super', str:concat(subscriber, \"@carbon.super\"), subscriber) as subscriber, ifThenElse(apiCreatorTenantDomain == 'carbon.super', str:concat(apiCreator, \"@carbon.super\"), apiCreator) as apiCreator, apiName, applicationId, applicationName, apiCreatorTenantDomain, userTenantDomain, str:concat(applicationName, \" Application frequently goes beyond the allocated quota when accessing \", apiName, ' ', apiVersion) as message, ${severityLevel} as severity, (time:timestampInMilliseconds()) as alertTimestamp\ninsert into TierLimitHittingAlertStream;\n\n@info(name = 'Query generates TierLimitHittingAlertStream from supressedUserStream')\nfrom SuppressedTemporaryUserStream\nselect ifThenElse(userTenantDomain == 'carbon.super', str:concat(subscriber, \"@carbon.super\"), subscriber) as subscriber, ifThenElse(apiCreatorTenantDomain == 'carbon.super', str:concat(apiCreator, \"@carbon.super\"), apiCreator) as apiCreator, apiName, applicationId, applicationName, apiCreatorTenantDomain, userTenantDomain, str:concat(\"User \", username, \" frequently crosses the limit set.\") as message, ${severityLevel} as severity, (time:timestampInMilliseconds()) as alertTimestamp\ninsert into TierLimitHittingAlertStream;\n"
               }
            ],
            "properties": {
               "countingTime": {
                  "fieldName": "Counting Time Interval",
                  "description": "Time period (day/hours/min) of which the request count would be taken. This should be greater than 1 minute.",
                  "defaultValue": "1 hours"
               },
               "numOfTierCrossing": {
                  "fieldName": "No of Tier Crossing",
                  "description": "Max Number of tier crossings for the given time window",
                  "defaultValue": "10"
               },
               "alertSuppressionTime": {
                  "fieldName": "Alert Suppression Period",
                  "description": "Time period to wait before re sending the same alert in minutes",
                  "defaultValue": "10 "
               },
               "severityLevel": {
                  "fieldName": "Severity Level",
                  "description": " Severity level of the alert:(1:severe,2:moderate,3:mild)",
                  "defaultValue": "3",
                  "options": [
                     "1",
                     "2",
                     "3"
                  ]
               }
            }
         },
         {
            "uuid": "apim_alert_health_availability",
            "name": "APIM Health Availability Alert",
            "description": "Monitors the Health of an API",
            "type": "template",
            "instanceCount": "one",
            "script": "",
            "templates": [
               {
                  "type": "siddhiApp",
                  "content": "@App:name(\"apim_alert_health_availability_0\")\n@App:description(\"Determines the availablity and health of an api\")\n\ndefine trigger LoadInMemoryTable at 'start';\ndefine trigger PeriodicTrigger at every 5 minutes;\n\n@source(type = 'inMemory' , topic = 'APIM_REQUEST')\ndefine stream Request (meta_clientType string, applicationConsumerKey string, applicationName string, applicationId string, applicationOwner string, apiContext string, apiName string, apiVersion string, apiResourcePath string, apiResourceTemplate string, apiMethod string, apiCreator string, apiCreatorTenantDomain string, apiTier string, apiHostname string, username string, userTenantDomain string, userIp string, userAgent string, requestTimestamp long, throttledOut bool, responseTime long, serviceTime long, backendTime long, responseCacheHit bool, responseSize long, protocol string, responseCode int, destination string, securityLatency long, throttlingLatency long, requestMedLat long, responseMedLat long, backendLatency long, otherLatency long, gatewayType string, label string);\n\ndefine stream SuppressedResponseTimeAlertStream(apiName string, apiVersion string, apiContext string, apiCreator string, apiCreatorTenantDomain string, thresholdResponseTime long);\n\ndefine stream SuppressedResponseCodeAlertStream(apiName string, apiVersion string, apiContext string, apiCreator string, apiCreatorTenantDomain string);\n\n@sink(type = 'inMemory', topic = 'ApimApiHealthMonitorAlertStream')\ndefine stream ApiHealthMonitorAlertStream(apiName string, apiVersion string, apiCreator string, apiCreatorTenantDomain string, message string, severity int, alertTimestamp long);\n\n@store(type = 'rdbms', datasource = 'APIM_ANALYTICS_DB')\n@PrimaryKey('apiName', 'apiVersion', 'apiCreator', 'apiCreatorTenantDomain')\ndefine table ApiCreatorAlertConfiguration (apiName string, apiVersion string, apiCreator string, apiCreatorTenantDomain string, thresholdResponseTime long, thresholdBackendTime long);\n\n@PrimaryKey('apiName', 'apiVersion', 'apiCreator', 'apiCreatorTenantDomain')\ndefine table ApiCreatorAlertConfigurationInMemoryTable (apiName string, apiVersion string, apiCreator string, apiCreatorTenantDomain string, thresholdResponseTime long);\n\n@info(name = 'creatorConfigurationInfoRetrievQuery')\nfrom Request as R left outer join ApiCreatorAlertConfigurationInMemoryTable as C\n \ton(R.apiName == C.apiName and R.apiVersion == C.apiVersion and R.apiCreator == C.apiCreator and R.apiCreatorTenantDomain == C.apiCreatorTenantDomain )\nselect R.apiContext, R.apiName, R.apiVersion, R.apiResourceTemplate, R.apiMethod, R.apiCreator, R.apiCreatorTenantDomain, R.requestTimestamp, R.responseTime, R.backendTime, C.thresholdResponseTime, R.responseCode\ninsert into RequestAlertInfoStream;\n\npartition with (apiContext of RequestAlertInfoStream)\nbegin\n -- checks whether the response time is higher than the threshold response time continously for 5 times\n \tfrom RequestAlertInfoStream[not thresholdResponseTime is null]\n \tselect *\n \tinsert into TempStream;\n \t@info(name = 'Abnormal response time pattern check')\n \tfrom every e1 = TempStream[thresholdResponseTime >0 and responseTime > thresholdResponseTime],e2 = TempStream[thresholdResponseTime >0 and responseTime > thresholdResponseTime],e3 = TempStream[thresholdResponseTime >0 and responseTime > thresholdResponseTime], e4 = TempStream[thresholdResponseTime >0 and responseTime > thresholdResponseTime],e5 = TempStream[thresholdResponseTime >0 and responseTime > thresholdResponseTime]\n \tselect e1.apiName, e1.apiVersion, e1.apiContext, e1.apiCreator, e1.apiCreatorTenantDomain, e1.thresholdResponseTime\n \tinsert into ResponseTimeAlertStream;\n\n --checks whether the response code is between 500 - 600 to identify a server error\n \t@info(name = 'Abnormal response code pattern check')\n \tfrom every e1 = Request[responseCode >= 500 and responseCode < 600],e2 = Request[responseCode >= 500 and responseCode < 600],e3 = Request[responseCode >= 500 and responseCode < 600], e4 = Request[responseCode >= 500 and responseCode < 600],e5 = Request[responseCode >= 500 and responseCode < 600]\n \tselect e1.apiName, e1.apiVersion, e1.apiContext, e1.apiCreator, e1.apiCreatorTenantDomain\n \tinsert into ResponseCodeAlertStream;\n\nend;\n\n@info(name = 'ResponseTime Alert Suppression')\nfrom ResponseTimeAlertStream#window.length(1) as a left outer join SuppressedResponseTimeAlertStream#window.time(${alertSuppressionTime} minutes) as b\n \ton a.apiName == b.apiName and a.apiVersion == b.apiVersion and a.apiCreator == b.apiCreator and a.apiCreatorTenantDomain == b.apiCreatorTenantDomain\nselect a.apiName, a.apiVersion, a.apiContext, a.apiCreator, a.apiCreatorTenantDomain, a.thresholdResponseTime\n \thaving b.apiName is null\ninsert into SuppressedResponseTimeAlertStream;\n\n@info(name = 'ResponseCode Alert Suppression')\nfrom ResponseCodeAlertStream#window.length(1) as a left outer join SuppressedResponseCodeAlertStream#window.time(${alertSuppressionTime} minutes) as b\n \ton a.apiName == b.apiName and a.apiVersion == b.apiVersion and a.apiCreator == b.apiCreator and a.apiCreatorTenantDomain == b.apiCreatorTenantDomain\nselect a.apiName, a.apiVersion, a.apiContext, a.apiCreator, a.apiCreatorTenantDomain\n \thaving b.apiName is null\ninsert into SuppressedResponseCodeAlertStream;\n\n@info(name = 'Query generates ApiHealthMonitorAlertStreamTemp with message for high response time alert')\nfrom SuppressedResponseTimeAlertStream\nselect apiName, apiVersion, ifThenElse(apiCreatorTenantDomain == 'carbon.super', str:concat(apiCreator, \"@carbon.super\"), apiCreator) as apiCreator, apiCreatorTenantDomain, str:concat('Response time is higher than ' , convert(thresholdResponseTime, 'string'), ' ms continuously for 5 or more responses.') as message, ${severityLevel} as severity, (time:timestampInMilliseconds()) as alertTimestamp\ninsert into ApiHealthMonitorAlertStream;\n\n@info(name = 'Query generates ApiHealthMonitorAlertStreamTemp with message for server error alert')\nfrom SuppressedResponseCodeAlertStream\nselect apiName, apiVersion, ifThenElse(apiCreatorTenantDomain == 'carbon.super', str:concat(apiCreator, \"@carbon.super\"), apiCreator) as apiCreator, apiCreatorTenantDomain, 'Server error occurred continuously for 5 or more times.' as message, ${severityLevel} as severity, (time:timestampInMilliseconds()) as alertTimestamp\ninsert into ApiHealthMonitorAlertStream;\n\n@info(name='Update IntermediateStream') \nfrom LoadInMemoryTable \nselect triggered_time \ninsert into InMemoryTableJoinStream;\n\n@info(name='Update IntermediateStream periodically') \nfrom PeriodicTrigger  \nselect triggered_time \ninsert into InMemoryTableJoinStream;\n\n-- Update the AlertCreatorConfig Table @ start\n@info(name = 'Load ApiCreatorAlertConfigurationInMemoryTable')\nfrom InMemoryTableJoinStream join ApiCreatorAlertConfiguration\nselect apiName, apiVersion, apiCreator, apiCreatorTenantDomain, thresholdResponseTime\nupdate or\ninsert into ApiCreatorAlertConfigurationInMemoryTable\nset ApiCreatorAlertConfiguration.thresholdResponseTime = thresholdResponseTime\n \ton ApiCreatorAlertConfigurationInMemoryTable.apiName == apiName and ApiCreatorAlertConfigurationInMemoryTable.apiVersion == apiVersion and ApiCreatorAlertConfigurationInMemoryTable.apiCreator == apiCreator and ApiCreatorAlertConfigurationInMemoryTable.apiCreatorTenantDomain == apiCreatorTenantDomain;\n"
               }
            ],
            "properties": {
               "alertSuppressionTime": {
                  "fieldName": "Alert Suppression period",
                  "description": "Same alert will be sent only once within this time period",
                  "defaultValue": "10"
               },
               "severityLevel": {
                  "fieldName": "Severity Level",
                  "description": "Severity level of the alert:(1:severe,2:moderate,3:mild)",
                  "defaultValue": "2",
                  "options": [
                     "1",
                     "2",
                     "3"
                  ]
               }
            }
         },
         {
            "uuid": "apim_alert_unusual_ip_access",
            "name": "APIM Unusual IP Access Alert",
            "description": "Monitoring API health",
            "type": "template",
            "instanceCount": "one",
            "script": "",
            "templates": [
               {
                  "type": "siddhiApp",
                  "content": "@App:name(\"apim_alert_unusual_ip_access_0\")\n@App:description(\"Alerts if an access from a strange ip is detected\")\n\n@source(type = 'inMemory' , topic = 'APIM_REQUEST')\ndefine stream Request (meta_clientType string, applicationConsumerKey string, applicationName string, applicationId string, applicationOwner string, apiContext string, apiName string, apiVersion string, apiResourcePath string, apiResourceTemplate string, apiMethod string, apiCreator string, apiCreatorTenantDomain string, apiTier string, apiHostname string, username string, userTenantDomain string, userIp string, userAgent string, requestTimestamp long, throttledOut bool, responseTime long, serviceTime long, backendTime long, responseCacheHit bool, responseSize long, protocol string, responseCode int, destination string, securityLatency long, throttlingLatency long, requestMedLat long, responseMedLat long, backendLatency long, otherLatency long, gatewayType string, label string);\n\n@sink(type = 'inMemory' , topic = 'IpAccessAbnormalityAlertStream')\ndefine stream IpAccessAbnormalityAlertStream(type string, message string, severity int, ip string, applicationName string, applicationOwner string, username string, tenantDomain string, requestTimestamp long, alertTimestamp long);\n\n@Async(buffer.size = '32768', workers = '1', batch.size.max = '1024')\ndefine stream ApimIPAccessSummaryUpdateStream(username string, applicationConsumerKey string, ip string, lastAccessedDate long);\n\n@Async(buffer.size = '32768', workers = '1', batch.size.max = '1024')\ndefine stream ApimIPAccessAlertCountUpdateStream(username string, applicationConsumerKey string, requestCount long);\n\n@store(type = 'rdbms', datasource = 'APIM_ANALYTICS_DB')\n@PrimaryKey('applicationConsumerKey', 'ip')\n@index('applicationConsumerKey', 'ip', 'username')\ndefine table ApimIPAccessSummary (username string, applicationConsumerKey string, ip string, lastAccessedDate long) ;\n\n@store(type = 'rdbms', datasource = 'APIM_ANALYTICS_DB')\n@PrimaryKey('applicationConsumerKey', 'username')\ndefine table ApimIPAccessAlertCount (username string, applicationConsumerKey string, requestCount long);\n\n@info(name = 'Query generates TempStream')\nfrom Request\nselect applicationConsumerKey, applicationOwner, applicationName, username, userTenantDomain, userIp, requestTimestamp\n \tgroup by applicationConsumerKey, username, userIp\n \toutput last every 1 minute\ninsert into RequestBufferStream;\n\n@info(name='Join with ApimIPAccessAlertCount')\nfrom RequestBufferStream#window.length(1) as R join ApimIPAccessAlertCount as T\n \ton (R.applicationConsumerKey == T.applicationConsumerKey and R.username == T.username)\nselect R.applicationConsumerKey, R.applicationOwner, R.applicationName, R.username, R.userTenantDomain, R.userIp as ip, requestCount, requestTimestamp\ninsert into TempStream;\n\n@info(name='Filterout new users')\nfrom TempStream[requestCount > ${minReqCountPerUser}]\nselect applicationConsumerKey, applicationOwner, applicationName, username, userTenantDomain, ip, requestTimestamp\ninsert into TempStream2;\n\n@info(name = 'Query generates ExistingUserStream')\nfrom TempStream2 as ts left outer join ApimIPAccessSummary as iaac\n \ton ts.username == iaac.username and ts.applicationConsumerKey == iaac.applicationConsumerKey and ts.ip == iaac.ip\nselect ts.applicationConsumerKey, ts.applicationName , ts.applicationOwner, ts.username, ts.userTenantDomain as tenantDomain, ts.ip as requestIp, iaac.ip as ip, ts.requestTimestamp, (requestTimestamp - lastAccessedDate) as timeBetweenAccess\ninsert into ExistingUserStream;\n\n--If a new ip is detected from the particular username and applicationConsumerKey Note: ip will be null if its a new ip from the user\n@info(name = 'query generates NewIPDetectedStream')\nfrom ExistingUserStream[ip is null]\nselect \"UnusualIPAccess\" as type, \"A request from a new IP detected.\" as message, ${severityLevel} as severity, requestIp as ip, applicationName, ifThenElse(tenantDomain == 'carbon.super', str:concat(applicationOwner, \"@carbon.super\"), applicationOwner) as applicationOwner, username, tenantDomain, requestTimestamp, (time:timestampInMilliseconds()) as alertTimestamp\ninsert into IpAccessAbnormalityAlertStream;\n\n-- If IP is already used Check if the request for the IP is received after the threshold time gap\n@info(name = 'query generates CheckAbnormalTimeBetweenAccessStream ')\nfrom ExistingUserStream[(not (ip is null)) and timeBetweenAccess > ${diffOFLastAccessTimePerIP} days ]\nselect \"UnusualIPAccess\" as type, \"A request from an old IP detected.\" as message, ${severityLevel} as severity, requestIp as ip, applicationName, ifThenElse(tenantDomain == 'carbon.super', str:concat(applicationOwner, \"@carbon.super\"), applicationOwner) as applicationOwner, username, tenantDomain , requestTimestamp, (time:timestampInMilliseconds()) as alertTimestamp\ninsert into IpAccessAbnormalityAlertStream;\n\n@info(name = 'Batch Events ApimIPAccessSummaryUpdateStream')\nfrom Request\nselect username, applicationConsumerKey, userIp as ip, requestTimestamp as lastAccessedDate\n \tgroup by applicationConsumerKey, apiHostname, username\n \toutput last every 10 minutes\ninsert into ApimIPAccessSummaryUpdateStream;\n\n@info(name = 'Update/Insert ApimIPAccessSummaryUpdate')\nfrom ApimIPAccessSummaryUpdateStream\nselect *\nupdate or\ninsert into ApimIPAccessSummary\nset ApimIPAccesSummary.lastAccessedDate = lastAccessedDate, ApimIPAccessSummary.username = username\n \ton ApimIPAccessSummary.applicationConsumerKey == applicationConsumerKey and ApimIPAccessSummary.ip == ip;\n\n@info(name = 'Batch Events ApimIPAccessAlertCountUpdateStream')\nfrom Request\nselect username, applicationConsumerKey, count() as requestCount\n \tgroup by applicationConsumerKey, username\n \toutput last every 10 minutes\ninsert into ApimIPAccessAlertCountUpdateStream;\n\n@info(name = 'Update/Insert ApimIPAccessAlertCount')\nfrom ApimIPAccessAlertCountUpdateStream\nselect *\nupdate or\ninsert into ApimIPAccessAlertCount\nset ApimIPAccessAlertCount.requestCount = ApimIPAccessAlertCount.requestCount + requestCount\n \ton ApimIPAccessAlertCount.applicationConsumerKey == applicationConsumerKey and ApimIPAccessAlertCount.username == username;\n"
               }
            ],
            "properties": {
               "minReqCountPerUser": {
                  "fieldName": "Minimum Number of Request Count Per User ",
                  "description": "Minimum number of request that has to be sent by user to send alert",
                  "defaultValue": "100"
               },
               "severityLevel": {
                  "fieldName": "Severity Level",
                  "description": "Severity level of the alert:(1:severe,2:moderate,3:mild)",
                  "defaultValue": "2",
                  "options": [
                     "1",
                     "2",
                     "3"
                  ]
               },
               "diffOFLastAccessTimePerIP": {
                  "fieldName": "Maximum Days Between Last Access",
                  "description": "Maximum days between Last access from the hostname to the latest",
                  "defaultValue": "30"
               }
            }
         },
         {
            "uuid": "apim_alert_abnormal_response_time",
            "name": "APIM  Abnormal Response Time",
            "description": "Detects requests with response time greater than a configured threshold value and triggers an alert",
            "type": "template",
            "instanceCount": "one",
            "script": "",
            "templates": [
               {
                  "type": "siddhiApp",
                  "content": "@App:name(\"apim_alert_abnormal_response_time_0\")\n@App:description(\"Identifies the API requests with abnormal response time and add to AllAlertStream and AbnormalResponseTimeAlertStream\")\n\ndefine trigger LoadInMemoryTable at 'start';\ndefine trigger PeriodicTrigger at every 5 minutes;\n\n@source(type='inMemory' , topic='APIM_REQUEST')\ndefine stream Request (meta_clientType string, applicationConsumerKey string, applicationName string, applicationId string, applicationOwner string, apiContext string,apiName string, apiVersion string, apiResourcePath string, apiResourceTemplate string, apiMethod string, apiCreator string, apiCreatorTenantDomain string, apiTier string, apiHostname string, username string, userTenantDomain string, userIp string, userAgent string, requestTimestamp long, throttledOut bool, responseTime long, serviceTime long, backendTime long, responseCacheHit bool, responseSize long, protocol string, responseCode int, destination string, securityLatency long, throttlingLatency long, requestMedLat long, responseMedLat long, backendLatency long, otherLatency long, gatewayType string, label string);\n\ndefine stream SuppressedAbnormalResponseTimeAlertStream(apiName string, apiVersion string, apiCreator string, apiCreatorTenantDomain string, apiResourceTemplate string, apiMethod string, responseTime long, thresholdResponseTime long);\n\n@sink(type='inMemory' , topic='AbnormalResponseTimeAlertStream')\ndefine stream AbnormalResponseTimeAlertStream( apiName string, apiVersion string, apiCreator string, apiCreatorTenantDomain string, apiResourceTemplate string, apiMethod string, responseTime long, thresholdResponseTime long, message string, severity int,alertTimestamp long);\n\n@store(type = 'rdbms', datasource = 'APIM_ANALYTICS_DB')\n@PrimaryKey('apiName', 'apiVersion','apiCreator', 'apiCreatorTenantDomain')\ndefine table ApiCreatorAlertConfiguration (apiName string, apiVersion string, apiCreator string, apiCreatorTenantDomain string, thresholdResponseTime long, thresholdBackendTime long);\n\n@PrimaryKey('apiName', 'apiVersion','apiCreator', 'apiCreatorTenantDomain')\ndefine table ApiCreatorAlertConfigurationInMemoryTable (apiName string, apiVersion string, apiCreator string, apiCreatorTenantDomain string, thresholdResponseTime long);\n\n@info(name = 'creatorConfigurationInfoRetrievQuery')\nfrom Request as R join ApiCreatorAlertConfigurationInMemoryTable as C\non (R.apiName == C.apiName and R.apiVersion == C.apiVersion and R.apiCreator== C.apiCreator and R.apiCreatorTenantDomain == C.apiCreatorTenantDomain)\nselect R.apiName, R.apiVersion,  R.apiCreator, R.apiCreatorTenantDomain, R.apiResourceTemplate, R.apiMethod, R.responseTime, thresholdResponseTime\ninsert into AbnormalResponseTimeAlertStreamTemp;\n\n@info(name='FilterForAlerting')\nfrom AbnormalResponseTimeAlertStreamTemp[thresholdResponseTime >0 and responseTime > thresholdResponseTime ]\nselect *\ninsert into AbnormalResponseTimeAlertStreamTemp2;\n\n@info(name = 'Alert Suppression')\nfrom AbnormalResponseTimeAlertStreamTemp2#window.length(1) as a left outer join SuppressedAbnormalResponseTimeAlertStream#window.time(${alertSuppressionTime} minute) as b\non (a.apiName == b.apiName and a.apiVersion== b.apiVersion and a.apiCreator== b.apiCreator and a.apiCreatorTenantDomain==b.apiCreatorTenantDomain and\n    a.apiResourceTemplate==b.apiResourceTemplate and a.apiMethod== b.apiMethod)\nselect a.apiName, a.apiVersion, a.apiCreator, a.apiCreatorTenantDomain, a.apiResourceTemplate, a.apiMethod, a.responseTime, a.thresholdResponseTime\nhaving b.apiName  is null\ninsert into SuppressedAbnormalResponseTimeAlertStream;\n\nfrom SuppressedAbnormalResponseTimeAlertStream\nselect apiName, apiVersion,  ifThenElse(apiCreatorTenantDomain == 'carbon.super', str:concat(apiCreator, \"@carbon.super\"), apiCreator) as apiCreator, apiCreatorTenantDomain, apiResourceTemplate, apiMethod, responseTime, thresholdResponseTime ,\n    'Abnormal response time detected.' as message, ${severityLevel} as severity, (time:timestampInMilliseconds()) as alertTimestamp\ninsert into AbnormalResponseTimeAlertStream;\n\n@info(name='Update IntermediateStream') \nfrom LoadInMemoryTable \nselect triggered_time \ninsert into InMemoryTableJoinStream;\n\n@info(name='Update IntermediateStream periodically') \nfrom PeriodicTrigger  \nselect triggered_time \ninsert into InMemoryTableJoinStream;\n\n-- Update the AlertCreatorConfig Table @ start\n@info(name = 'Load ApiCreatorAlertConfigurationInMemoryTable')\nfrom InMemoryTableJoinStream join ApiCreatorAlertConfiguration\nselect apiName, apiVersion, apiCreator, apiCreatorTenantDomain, thresholdResponseTime\nupdate or\ninsert into ApiCreatorAlertConfigurationInMemoryTable\nset ApiCreatorAlertConfiguration.thresholdResponseTime = thresholdResponseTime\n \ton ApiCreatorAlertConfigurationInMemoryTable.apiName == apiName and ApiCreatorAlertConfigurationInMemoryTable.apiVersion == apiVersion and ApiCreatorAlertConfigurationInMemoryTable.apiCreator == apiCreator and ApiCreatorAlertConfigurationInMemoryTable.apiCreatorTenantDomain == apiCreatorTenantDomain;\n"
               }
            ],
            "properties": {
               "alertSuppressionTime": {
                  "fieldName": "Alert Suppression Period in Minutes",
                  "description": "Time period to wait before resending the same alert",
                  "defaultValue": "10"
               },
               "severityLevel": {
                  "fieldName": "Severity Level of Abnormal Response Time",
                  "description": "Severity level of the abnormal response time alert:(1:severe,2:moderate,3:mild)",
                  "defaultValue": "3",
                  "options": [
                     "1",
                     "2",
                     "3"
                  ]
               }
            }
         },
         {
            "uuid": "apim_alert_abnormal_backend_time",
            "name": "APIM Abnormal Back End Time",
            "description": "Detects requests with backend time greater than a configured threshold value and triggers an alert",
            "type": "template",
            "instanceCount": "one",
            "script": "",
            "templates": [
               {
                  "type": "siddhiApp",
                  "content": "@App:name(\"apim_alert_abnormal_backend_time_0\")\n@App:description(\"Identifies the API requests with abnormal backend time and add to AllAlertStream and AbnormalBackendTimeAlertStream\")\n\ndefine trigger LoadInMemoryTable at 'start';\ndefine trigger PeriodicTrigger at every 5 minutes;\n\n@source(type = 'inMemory' , topic = 'APIM_REQUEST')\ndefine stream Request (meta_clientType string, applicationConsumerKey string, applicationName string, applicationId string, applicationOwner string, apiContext string, apiName string, apiVersion string, apiResourcePath string, apiResourceTemplate string, apiMethod string, apiCreator string, apiCreatorTenantDomain string, apiTier string, apiHostname string, username string, userTenantDomain string, userIp string, userAgent string, requestTimestamp long, throttledOut bool, responseTime long, serviceTime long, backendTime long, responseCacheHit bool, responseSize long, protocol string, responseCode int, destination string, securityLatency long, throttlingLatency long, requestMedLat long, responseMedLat long, backendLatency long, otherLatency long, gatewayType string, label string);\n\ndefine stream SuppressedAbnormalBackendTimeAlertStream(apiName string, apiVersion string, apiCreator string, apiCreatorTenantDomain string, apiResourceTemplate string, apiMethod string, backendTime long, thresholdBackendTime long);\n\n@sink(type = 'inMemory' , topic = 'AbnormalBackendTimeAlertStream')\ndefine stream AbnormalBackendTimeAlertStream( apiName string, apiVersion string, apiCreator string, apiCreatorTenantDomain string, apiResourceTemplate string, apiMethod string, backendTime long, thresholdBackendTime long, message string, severity int, alertTimestamp long);\n\n@store(type = 'rdbms', datasource = 'APIM_ANALYTICS_DB')\n@PrimaryKey('apiName', 'apiVersion', 'apiCreator', 'apiCreatorTenantDomain')\ndefine table ApiCreatorAlertConfiguration (apiName string, apiVersion string, apiCreator string, apiCreatorTenantDomain string, thresholdResponseTime long, thresholdBackendTime long);\n\n@PrimaryKey('apiName', 'apiVersion', 'apiCreator', 'apiCreatorTenantDomain')\ndefine table ApiCreatorAlertConfigurationInMemoryTable (apiName string, apiVersion string, apiCreator string, apiCreatorTenantDomain string, thresholdBackendTime long);\n\n-- Join the request stream with in memory configuration tables to get threashold values.\n@info(name = 'creatorConfigurationInfoRetrieveQuery')\nfrom Request as R join ApiCreatorAlertConfigurationInMemoryTable as C\n\ton (R.apiName == C.apiName and R.apiVersion == C.apiVersion and R.apiCreator == C.apiCreator and R.apiCreatorTenantDomain == C.apiCreatorTenantDomain)\nselect R.apiName, R.apiVersion, R.apiCreator, R.apiCreatorTenantDomain, R.apiResourceTemplate, R.apiMethod, R.backendTime, C.thresholdBackendTime\ninsert into AbnormalBackendTimeAlertStreamTemp;\n\n@info(name = 'FilterForAlerting')\nfrom AbnormalBackendTimeAlertStreamTemp[ thresholdBackendTime > 0 and backendTime > thresholdBackendTime ]\nselect *\ninsert into AbnormalBackendTimeAlertStreamTemp2;\n\n@info(name = 'Alert Suppression')\nfrom AbnormalBackendTimeAlertStreamTemp2#window.length(1) as a left outer join SuppressedAbnormalBackendTimeAlertStream#window.time(${alertSuppressionTime} minute) as b\n\ton (a.apiName == b.apiName and a.apiVersion == b.apiVersion and a.apiCreator == b.apiCreator and a.apiCreatorTenantDomain == b.apiCreatorTenantDomain and a.apiResourceTemplate == b.apiResourceTemplate and a.apiMethod == b.apiMethod)\nselect a.apiName, a.apiVersion, a.apiCreator, a.apiCreatorTenantDomain, a.apiResourceTemplate, a.apiMethod, a.backendTime, a.thresholdBackendTime\n\thaving b.apiName is null\ninsert into SuppressedAbnormalBackendTimeAlertStream;\n\n@info(name = 'Alert Templated')\nfrom SuppressedAbnormalBackendTimeAlertStream\nselect apiName, apiVersion, ifThenElse(apiCreatorTenantDomain == 'carbon.super', str:concat(apiCreator, \"@carbon.super\"), apiCreator) as apiCreator, apiCreatorTenantDomain, apiResourceTemplate, apiMethod, backendTime, thresholdBackendTime, 'Abnormal backend time detected.' as message, ${severityLevel} as severity, (time:timestampInMilliseconds()) as alertTimestamp\ninsert into AbnormalBackendTimeAlertStream;\n\n@info(name='Update IntermediateStream') \nfrom LoadInMemoryTable \nselect triggered_time \ninsert into InMemoryTableJoinStream;\n\n@info(name='Update IntermediateStream periodically') \nfrom PeriodicTrigger  \nselect triggered_time \ninsert into InMemoryTableJoinStream;\n\n-- Update the AlertCreatorConfig Table @ start\n@info(name = 'Load ApiCreatorAlertConfigurationInMemoryTable')\nfrom InMemoryTableJoinStream join ApiCreatorAlertConfiguration\nselect apiName, apiVersion, apiCreator, apiCreatorTenantDomain, thresholdBackendTime\nupdate or\ninsert into ApiCreatorAlertConfigurationInMemoryTable\nset ApiCreatorAlertConfiguration.thresholdBackendTime = thresholdBackendTime\n\ton ApiCreatorAlertConfigurationInMemoryTable.apiName == apiName and ApiCreatorAlertConfigurationInMemoryTable.apiVersion == apiVersion and ApiCreatorAlertConfigurationInMemoryTable.apiCreator == apiCreator and ApiCreatorAlertConfigurationInMemoryTable.apiCreatorTenantDomain == apiCreatorTenantDomain;\n"
               }
            ],
            "properties": {
               "alertSuppressionTime": {
                  "fieldName": "Alert Suppression Period in Minutes",
                  "description": "Time period to wait before resending the same alert",
                  "defaultValue": "10"
               },
               "severityLevel": {
                  "fieldName": "Severity Level of Abnormal Backend Time",
                  "description": "Severity level of the abnormal backend time alert:(1:severe,2:moderate,3:mild)",
                  "defaultValue": "3",
                  "options": [
                     "1",
                     "2",
                     "3"
                  ]
               }
            }
         },
         {
            "uuid": "apim_alert_abnormal_request_count",
            "name": "APIM Abnormal Request Count",
            "description": "Triggers an alert if the number of requests per minute for an application is greater than a configured threshold",
            "type": "template",
            "instanceCount": "one",
            "script": "",
            "templates": [
               {
                  "type": "siddhiApp",
                  "content": "@App:name(\"apim_alert_abnormal_request_count_0\")\n@App:description(\"Identifies the API requests with abnormal request count per minute and add to AllAlertStream and AbnormalRequestCountAlertStream\")\n\ndefine trigger LoadInMemoryTable at 'start';\ndefine trigger MinTriggerEventStream at every 1 minute;\ndefine trigger PeriodicTrigger at every 5 minutes;\n\n-- This stream definition is only to define the Aggregation. It does not consume the actual API request.\ndefine stream Request (meta_clientType string, applicationConsumerKey string, applicationName string, applicationId string, applicationOwner string, apiContext string,apiName string, apiVersion string, apiResourcePath string, apiResourceTemplate string, apiMethod string, apiCreator string, apiCreatorTenantDomain string, apiTier string, apiHostname string, username string, userTenantDomain string, userIp string, userAgent string, requestTimestamp long, throttledOut bool, responseTime long, serviceTime long, backendTime long, responseCacheHit bool, responseSize long, protocol string, responseCode int, destination string, securityLatency long, throttlingLatency long, requestMedLat long, responseMedLat long, backendLatency long, otherLatency long, gatewayType string, label string);\n\ndefine stream SuppressedAbnormalRequestsCountStream(applicationName string, applicationOwner string, tenantDomain string, apiName string, apiVersion string, requestCountPerMin long, thresholdRequestCountPerMin int);\n\n@sink(type = 'inMemory' , topic = 'AbnormalRequestsCountAlertStream')\ndefine stream AbnormalRequestsCountAlertStream(applicationName string, applicationOwner string, tenantDomain string, apiName string, apiVersion string, requestCountPerMin long, thresholdRequestCountPerMin int, message string, severity int, alertTimestamp long);\n\ndefine stream ApiSubAlertConfInMemoryStream(applicationId string, apiName string, apiVersion string, thresholdRequestCountPerMin int);\n\ndefine stream ConfigDeleteStream(applicationId string, apiName string, apiVersion string);\n\n@store(type = 'rdbms', datasource = 'APIM_ANALYTICS_DB')\n@PrimaryKey('applicationId', 'apiName', 'apiVersion')\n@Index('applicationId', 'apiName', 'apiVersion', 'thresholdRequestCountPerMin')\ndefine table ApiSubAlertConf (applicationId string, subscriber string, apiName string, apiVersion string, thresholdRequestCountPerMin int);\n\n@PrimaryKey('applicationId', 'apiName', 'apiVersion')\ndefine table ApiSubAlertConfInMemory (applicationId string, apiName string, apiVersion string, thresholdRequestCountPerMin int);\n\n-- This aggregation definition is only for retrieving data. No data is actually aggregated from this.\n@store(type = 'rdbms', datasource = 'APIM_ANALYTICS_DB')\n@purge(enable = 'false')\ndefine aggregation ApiUserPerAppAgg\nfrom Request\nselect apiName, apiVersion, apiContext, apiCreator, apiCreatorTenantDomain, apiHostname, applicationId, applicationName, applicationOwner, username, userTenantDomain, count() as totalRequestCount, gatewayType, label, 'default' as regionalID\n\tgroup by apiContext, apiHostname, applicationId, username, userTenantDomain\n\taggregate by requestTimestamp every seconds...years;\n\n-- Generate a event every one minute. The time period within which the abnormal request count should be considered is substracted from the current timestamp.\n@info(name = 'Get past 2 minutes timestamp')\nfrom MinTriggerEventStream\nselect triggered_time as currentTimestamp, (triggered_time - 2*60*1000) as endTimestamp, coordination:isLeader() as isLeader\ninsert into LeaderAwarePeriodicalTriggerStream;\n\n@info(name = 'Leaders Trigger')\nfrom LeaderAwarePeriodicalTriggerStream[isLeader == true]\nselect currentTimestamp, endTimestamp\ninsert into LeadersPeriodicalTriggerStream;\n\n@info(name = 'requestsPerMinCountingQuery')\nfrom LeadersPeriodicalTriggerStream as T join ApiUserPerAppAgg as A\nwithin T.endTimestamp, T.currentTimestamp\n per \"minutes\"\nselect apiName, apiVersion, applicationId, applicationName, applicationOwner, userTenantDomain as tenantDomain, totalRequestCount as requestCountPerMin, gatewayType, label\n\tgroup by applicationId, apiContext, apiCreator, apiCreatorTenantDomain\ninsert current events into RequestsPerMinStream;\n\n@info(name = 'configurationInfoRetrieveQuery')\nfrom RequestsPerMinStream as R join ApiSubAlertConfInMemory as T\n\ton ( R.applicationId == T.applicationId and R.apiName == T.apiName and R.apiVersion == T.apiVersion)\nselect R.applicationName, R.applicationOwner, R.tenantDomain, R.apiName, R.apiVersion, R.requestCountPerMin, T.thresholdRequestCountPerMin\ninsert into AbnormalRequestsPerMinAlertStreamTemp;\n\n@info(name = 'FilterForAlerting')\nfrom AbnormalRequestsPerMinAlertStreamTemp[ requestCountPerMin > thresholdRequestCountPerMin ]\nselect *\ninsert into AbnormalRequestsPerMinAlertStreamTemp2;\n\n@info(name = 'Alert Suppression')\nfrom AbnormalRequestsPerMinAlertStreamTemp2#window.length(1) as a left outer join SuppressedAbnormalRequestsCountStream#window.time(${alertSuppressionTime} minute) as b\n\ton (a.applicationName == b.applicationName and a.applicationOwner == b.applicationOwner and a.tenantDomain == b.tenantDomain and\n a.apiName == b.apiName and a.apiVersion == b.apiVersion)\nselect a.applicationName, a.applicationOwner, a.tenantDomain, a.apiName, a.apiVersion, a.requestCountPerMin, a.thresholdRequestCountPerMin\n\thaving b.apiName is null\ninsert into SuppressedAbnormalRequestsCountStream;\n\n@info(name = 'Alert Templated')\nfrom SuppressedAbnormalRequestsCountStream\nselect applicationName, ifThenElse(tenantDomain == 'carbon.super', str:concat(applicationOwner, \"@carbon.super\"), applicationOwner) as applicationOwner, tenantDomain, apiName, apiVersion, requestCountPerMin, thresholdRequestCountPerMin, 'Abnormal request count detected during last minute.' as message , ${severityLevel} as severity, (time:timestampInMilliseconds()) as alertTimestamp\ninsert into AbnormalRequestsCountAlertStream;\n\n@info(name='Update IntermediateStream')\nfrom LoadInMemoryTable\nselect triggered_time\ninsert into InMemoryTableJoinStream;\n\n@info(name='Update IntermediateStream periodically')\nfrom PeriodicTrigger\nselect triggered_time\ninsert into InMemoryTableJoinStream;\n\n-- Update the ApiSubAlertConf Table @ start and @ every 5 minutes\n@info(name = 'Load ApiSubAlertConfInMemory')\nfrom InMemoryTableJoinStream join ApiSubAlertConf\n\ton thresholdRequestCountPerMin > 0\nselect applicationId, apiName, apiVersion, thresholdRequestCountPerMin\nupdate or\ninsert into ApiSubAlertConfInMemory\nset ApiSubAlertConfInMemory.thresholdRequestCountPerMin = thresholdRequestCountPerMin\n\ton ApiSubAlertConfInMemory.applicationId == applicationId and ApiSubAlertConfInMemory.apiName == apiName and ApiSubAlertConfInMemory.apiVersion == apiVersion;\n\n-- Delete the removed configs from ApiSubAlertConfInMemory @ every 5 minutes\n@info(name = 'Load ApiSubAlertConfInMemory table')\nfrom PeriodicTrigger join ApiSubAlertConfInMemory\nselect applicationId, apiName, apiVersion, thresholdRequestCountPerMin\ninsert into ApiSubAlertConfInMemoryStream;\n\n@info(name = 'Update ConfigDeleteStream')\nfrom ApiSubAlertConf as a right outer join ApiSubAlertConfInMemoryStream as b\n\ton (a.applicationId == b.applicationId and a.apiName == b.apiName and a.apiVersion == b.apiVersion)\nselect b.applicationId as applicationId, b.apiName as apiName, b.apiVersion as apiVersion\n\thaving a.apiName is null\ninsert into ConfigDeleteStream;\n\n@info(name = 'Delete from ApiSubAlertConfInMemory table')\nfrom ConfigDeleteStream\nselect applicationId, apiName, apiVersion\ndelete ApiSubAlertConfInMemory\n\ton ApiSubAlertConfInMemory.applicationId == applicationId and ApiSubAlertConfInMemory.apiName == apiName and ApiSubAlertConfInMemory.apiVersion == apiVersion;\n"
               }
            ],
            "properties": {
               "alertSuppressionTime": {
                  "fieldName": "Alert Suppression Period in Minutes",
                  "description": "Time period to wait before resending the same alert",
                  "defaultValue": "10"
               },
               "severityLevel": {
                  "fieldName": "Severity Level of Abnormal Request Count",
                  "description": "Severity level of abnormal request count per minute alert:(1:severe,2:moderate,3:mild)",
                  "defaultValue": "2",
                  "options": [
                     "1",
                     "2",
                     "3"
                  ]
               }
            }
         },
         {
            "uuid": "apim_alert_abnormal_request_pattern",
            "name": "APIM Abnormal Request Pattern",
            "description": "Triggers an alert if there is a change in the resource access pattern of a for a particular application",
            "type": "template",
            "instanceCount": "one",
            "script": "",
            "templates": [
               {
                  "type": "siddhiApp",
                  "content": "@App:name(\"apim_alert_abnormal_request_pattern_0\")\n@App:description(\"Identifies the API requests wchich are outside the normal access pattern and add to AllAlertStream and AbormalRequestPatternStream\")\n\n@source(type = 'inMemory' , topic = 'APIM_REQUEST')\ndefine stream Request (meta_clientType string, applicationConsumerKey string, applicationName string, applicationId string, applicationOwner string, apiContext string, apiName string, apiVersion string, apiResourcePath string, apiResourceTemplate string, apiMethod string, apiCreator string, apiCreatorTenantDomain string, apiTier string, apiHostname string, username string, userTenantDomain string, userIp string, userAgent string, requestTimestamp long, throttledOut bool, responseTime long, serviceTime long, backendTime long, responseCacheHit bool, responseSize long, protocol string, responseCode int, destination string, securityLatency long, throttlingLatency long, requestMedLat long, responseMedLat long, backendLatency long, otherLatency long, gatewayType string, label string);\n\ndefine stream SuppressedRequestPatternChangedAlertStream(username string, applicationName string, applicationOwner string, tenantDomain string, transition string);\n\n@sink(type = \"inMemory\", topic = \"RequestPatternChangedAlertStream\")\ndefine stream RequestPatternChangedAlertStream(username string, applicationName string, applicationOwner string, tenantDomain string, message string, transition string, severity int, alertTimestamp long);\n\n@info(name = 'stateStreamGenerateQuery')\nfrom Request\nselect userTenantDomain as tenantDomain, username, str:concat(username, '@', applicationId) as appSpecificUsername, applicationConsumerKey, applicationName, applicationOwner, str:concat(apiMethod, ' ', apiContext, ' ', apiResourceTemplate) as state, time:dateFormat(requestTimestamp, 'yyyy-MM-dd HH:mm:ss') as requestTimestamp\ninsert into StateStream;\n\n@info(name = 'markovChaniGenerateQuery')\nfrom StateStream#markov:markovChain(appSpecificUsername, state, ${durationToKeep} min, ${probabilityThreshold}, ${requestCount}, true)\nselect lastState as startState, transitionProbability, notify, state as endState, tenantDomain, username, applicationConsumerKey, applicationName, applicationOwner, requestTimestamp\ninsert into TransitionProbabilityStream;\n\n@info(name = 'abnormalPatternFilterQuery')\nfrom TransitionProbabilityStream [ notify ]\nselect username, requestTimestamp, str:concat(startState, ' to ', endState) as transition, transitionProbability, applicationConsumerKey, applicationName, applicationOwner, tenantDomain\ninsert into RequestPatternChangedStreamTemp;\n\n@info(name = 'repeatedAlertIgnoreQuery')\nfrom RequestPatternChangedStreamTemp#window.length(1) as a left outer join SuppressedRequestPatternChangedAlertStream#window.time(${alertSuppressionPeriod} minute) as b\n \ton ( a.username == b.username and a.applicationName == b.applicationName and a.applicationOwner == b.applicationOwner and a.tenantDomain == b.tenantDomain and a.transition == b.transition)\nselect a.username, a.applicationName, a.applicationOwner, a.tenantDomain, a.transition\n \thaving b.username is null\ninsert into SuppressedRequestPatternChangedAlertStream;\n\n@info(name = 'detailedAlertGenerateQuery')\nfrom SuppressedRequestPatternChangedAlertStream\nselect username, applicationName, ifThenElse(tenantDomain == 'carbon.super', str:concat(applicationOwner, \"@carbon.super\"), applicationOwner) as applicationOwner, tenantDomain, str:concat('Abnormal request pattern detected.' , ' Suspicious API transition is: ', transition) as message , transition, ${severityLevel} as severity, (time:timestampInMilliseconds()) as alertTimestamp\ninsert into RequestPatternChangedAlertStream;\n"
               }
            ],
            "properties": {
               "durationToKeep": {
                  "fieldName": "Duration to keep an event in minutes",
                  "description": "The maximum time duration to be considered for a continuous state change of a particular  user",
                  "defaultValue": "60"
               },
               "probabilityThreshold": {
                  "fieldName": "The alert threshold probability",
                  "description": "Alert is triggered if the probability is below this value. (0 < threshold < 1)",
                  "defaultValue": "0.2"
               },
               "requestCount": {
                  "fieldName": "Number of requests to train the model",
                  "description": "This number of requests is considered to train the Markov Matrix before generating alerts",
                  "defaultValue": "500"
               },
               "alertSuppressionPeriod": {
                  "fieldName": "Alert Suppression Period in Minutes",
                  "description": "Time period to wait before resending the same alert",
                  "defaultValue": "10"
               },
               "severityLevel": {
                  "fieldName": "Severity Level of Abnormal Response Time",
                  "description": "Severity level of the abnormal response time alert:(1:severe,2:moderate,3:mild)",
                  "defaultValue": "1",
                  "options": [
                     "1",
                     "2",
                     "3"
                  ]
               }
            }
         },
         {
            "uuid": "apim_analytics_data_purging_app",
            "name": "APIM DATA PURGING",
            "description": "Enables Data Purging",
            "type": "template",
            "instanceCount": "one",
            "script": "",
            "templates": [
               {
                  "type": "siddhiApp",
                  "content": "@App:name(\"apim_analytics_data_purging_app_0\") \n@App:description(\"App purges data of Raw tables in APIM Analytics\")\n\ndefine trigger IPAccessAlertCountPurgingTrigger at every ${accessRequestCountDeletionTriggerInterval};\n\n-- Runs at 12 AM every day\ndefine trigger IPAccessSummaryPurgingTrigger at '0 0 0 1/1 * ? *' ;\n\n-- Table Used in Unusual IP Access Alert\n@PrimaryKey('applicationConsumerKey','ip')\n@index('lastAccessedDate')\n@store(type = 'rdbms', datasource = 'APIM_ANALYTICS_DB')\ndefine table ApimIPAccessSummary (username string, applicationConsumerKey string, ip string, lastAccessedDate long) ;\n\n-- Table Used in Unusual IP Access Alert\n@PrimaryKey('applicationConsumerKey','username')\n@store(type = 'rdbms', datasource = 'APIM_ANALYTICS_DB')\ndefine table ApimIPAccessAlertCount (username string, applicationConsumerKey string, requestCount long) ;\n\n-- Derive the purging end timestamp based on the given retention period\nfrom IPAccessSummaryPurgingTrigger\nselect time:timestampInMilliseconds(time:dateSub(time:currentTimestamp(), ${accessSummaryPurgingRetentionPeriodAmount}, '${accessSummaryPurgingRetentionPeriodUnit}', 'yyyy-MM-dd HH:mm:ss'), 'yyyy-MM-dd HH:mm:ss') as purgingEndTimestamp\ninsert into IPAccessSummaryPurgingStream;\n\n-- Delete data that is older than the retention period, when the IPAccessAlertCountPurgingTrigger is triggered\nfrom IPAccessSummaryPurgingStream\ndelete ApimIPAccessSummary on ApimIPAccessSummary.lastAccessedDate < purgingEndTimestamp;\n\n-- Delete all Data from ApimIPAccessAlertCount, when the IPAccessAlertCountPurgingTrigger is triggered\nfrom IPAccessAlertCountPurgingTrigger\ndelete ApimIPAccessAlertCount on \"1\" == \"1\";"
               }
            ],
            "properties": {
               "accessRequestCountDeletionTriggerInterval": {
                  "fieldName": "Time Interval for IP Access Request Count Data Deletion",
                  "description": "All the existing APIM IP Access request count data, will be deleted per this interval",
                  "defaultValue": "1 years"
               },
               "accessSummaryPurgingRetentionPeriodAmount": {
                  "fieldName": "Last IP Access Retention Period Amount",
                  "description": "APIM IP Access Summary Data older than this much of the given unit, will be deleted everyday at 00:00",
                  "defaultValue": "1"
               },
               "accessSummaryPurgingRetentionPeriodUnit": {
                  "fieldName": "Last IP Access Retention Period Unit",
                  "description": "APIM IP Access Summary Data older than the given amount - measured in this unit, will be deleted everyday at 00:00",
                  "defaultValue": "years"
               }
            }
         }
      ]
   }
}